#!/bin/bash

# =============================================================================
# Postiz Management CLI
# =============================================================================
# Usage: ./postiz [install|update|jwt|reset-jwt|help]
# =============================================================================

set -e

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# --- Logging ---
log_info()  { echo -e "${GREEN}[✓ INFO]${NC}  $1"; }
log_warn()  { echo -e "${YELLOW}[⚠ WARN]${NC}  $1"; }
log_error() { echo -e "${RED}[✗ ERROR]${NC} $1"; }
log_step()  { echo -e "${CYAN}[→ STEP]${NC}  $1"; }

# --- Helpers ---
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Cross-platform sed -i wrapper
sedi() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

# Set or update a KEY=VALUE in .env (handles both quoted and unquoted values)
set_env_var() {
    local key="$1"
    local value="$2"
    local file="${3:-.env}"

    # Remove existing line(s) for this key
    sedi "/^${key}=/d" "$file"
    # Append new value
    echo "${key}=\"${value}\"" >> "$file"
}

# Get a value from .env
get_env_var() {
    local key="$1"
    local file="${2:-.env}"
    grep "^${key}=" "$file" 2>/dev/null | head -1 | cut -d '=' -f 2- | tr -d '"' | tr -d "'"
}

check_dependencies() {
    local missing=0
    log_step "Checking dependencies..."

    if ! command_exists docker; then
        log_error "Docker is not installed. Install: https://docs.docker.com/get-docker/"
        missing=1
    fi

    if ! docker compose version >/dev/null 2>&1; then
        log_error "Docker Compose V2 is not available."
        missing=1
    fi

    if ! command_exists git; then
        log_error "Git is not installed."
        missing=1
    fi

    if ! command_exists openssl; then
        log_error "OpenSSL is not installed (needed for JWT generation)."
        missing=1
    fi

    if [ "$missing" -eq 1 ]; then
        log_error "Please install the missing dependencies above and try again."
        exit 1
    fi

    log_info "All dependencies satisfied."
}

generate_jwt_secret() {
    openssl rand -base64 32 | tr -d '\n'
}

# =============================================================================
# INSTALL
# =============================================================================
cmd_install() {
    echo ""
    echo -e "${BOLD}╔══════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║        Postiz Interactive Installer       ║${NC}"
    echo -e "${BOLD}╚══════════════════════════════════════════╝${NC}"
    echo ""

    check_dependencies

    # --- Checkpoint 1: Detect existing installation ---
    log_step "Checkpoint 1: Checking for existing installation..."

    IS_FRESH=true
    if docker compose ps -q 2>/dev/null | grep -q .; then
        log_warn "Existing Docker containers detected for this project."
        echo -n "  Do you want to perform a FRESH install (deletes ALL data)? [y/N]: "
        read -r confirm_wipe
        if [[ "$confirm_wipe" =~ ^[Yy]$ ]]; then
            log_warn "Stopping containers and wiping all volumes..."
            docker compose down -v --remove-orphans 2>/dev/null || true
            rm -f .env docker-compose.override.yml
            IS_FRESH=true
        else
            log_info "Keeping existing data. Updating configuration only."
            IS_FRESH=false
        fi
    fi

    # --- Checkpoint 2: Create .env ---
    log_step "Checkpoint 2: Preparing environment file..."

    if [ ! -f .env ]; then
        if [ ! -f .env.example ]; then
            log_error ".env.example not found! Is this the Postiz repository?"
            exit 1
        fi
        cp .env.example .env
        log_info "Created .env from .env.example"
    else
        log_info ".env already exists."
    fi

    # --- Checkpoint 3: JWT Secret ---
    log_step "Checkpoint 3: Configuring JWT Secret..."

    CURRENT_JWT=$(get_env_var "JWT_SECRET")
    if [ -z "$CURRENT_JWT" ] || [ "$CURRENT_JWT" = "random string for your JWT secret, make it long" ]; then
        NEW_JWT=$(generate_jwt_secret)
        set_env_var "JWT_SECRET" "$NEW_JWT"
        log_info "Generated new unique JWT Secret."
    else
        log_info "JWT Secret already configured."
    fi

    # --- Checkpoint 4: Domain & URL Configuration ---
    log_step "Checkpoint 4: Domain & URL Configuration..."

    CURRENT_DOMAIN=$(get_env_var "DOMAIN")
    echo ""
    echo -e "  ${BOLD}Domain Setup${NC}"
    echo ""
    echo "  Caddy reverse proxy handles SSL automatically."
    echo "  For a custom domain, point your DNS A record to this server's IP."
    echo ""
    if [ -n "$CURRENT_DOMAIN" ] && [ "$CURRENT_DOMAIN" != "localhost" ]; then
        echo "  Current domain: ${CURRENT_DOMAIN}"
    fi
    echo -n "  Enter your domain (e.g. postiz.example.com) or press Enter for localhost: "
    read -r input_domain
    input_domain=${input_domain:-${CURRENT_DOMAIN:-localhost}}

    # Determine protocol and build URLs
    if [ "$input_domain" = "localhost" ] || [ "$input_domain" = "127.0.0.1" ]; then
        PROTOCOL="http"
        FULL_URL="${PROTOCOL}://${input_domain}"
        set_env_var "DOMAIN" "localhost"
        log_info "Using localhost mode (HTTP only, no SSL)."
    else
        PROTOCOL="https"
        FULL_URL="${PROTOCOL}://${input_domain}"
        set_env_var "DOMAIN" "$input_domain"
        log_info "Domain set to: ${input_domain}"
        echo ""
        echo -e "  ${YELLOW}┌─────────────────────────────────────────────────────┐${NC}"
        echo -e "  ${YELLOW}│  DNS SETUP REQUIRED                                 │${NC}"
        echo -e "  ${YELLOW}│                                                     │${NC}"
        echo -e "  ${YELLOW}│  Add an A record in your DNS provider:              │${NC}"
        echo -e "  ${YELLOW}│    ${input_domain}  →  <your-server-IP>      ${NC}"
        echo -e "  ${YELLOW}│                                                     │${NC}"
        echo -e "  ${YELLOW}│  Caddy will auto-obtain SSL from Let's Encrypt      │${NC}"
        echo -e "  ${YELLOW}│  once DNS propagates (usually 1-5 minutes).         │${NC}"
        echo -e "  ${YELLOW}└─────────────────────────────────────────────────────┘${NC}"
        echo ""
    fi

    set_env_var "MAIN_URL" "$FULL_URL"
    set_env_var "FRONTEND_URL" "$FULL_URL"
    set_env_var "NEXT_PUBLIC_BACKEND_URL" "${FULL_URL}/api"

    # --- Checkpoint 5: Database Configuration ---
    log_step "Checkpoint 5: Database Configuration..."

    echo ""
    echo "  How do you want to run Redis and PostgreSQL?"
    echo ""
    echo "    [1] Internal (Docker-based, easiest - recommended)"
    echo "        → Automatically runs Redis & Postgres in Docker containers"
    echo ""
    echo "    [2] External (provide your own managed databases)"
    echo "        → Use your own Redis & Postgres servers (e.g., AWS RDS, Railway)"
    echo ""
    echo -n "  Select [1/2] (default: 1): "
    read -r db_choice
    db_choice=${db_choice:-1}

    if [ "$db_choice" = "2" ]; then
        # --- External Database Setup ---
        log_info "Configuring external databases..."

        echo ""
        echo -e "  ${BOLD}--- Postiz Database ---${NC}"
        echo -n "  PostgreSQL URL (e.g. postgresql://user:pass@host:5432/postiz): "
        read -r pg_url
        if [ -z "$pg_url" ]; then
            log_error "PostgreSQL URL cannot be empty."
            exit 1
        fi

        echo -n "  Redis URL (e.g. redis://host:6379): "
        read -r redis_url
        if [ -z "$redis_url" ]; then
            log_error "Redis URL cannot be empty."
            exit 1
        fi

        echo ""
        echo -e "  ${BOLD}--- Temporal Database (Separate) ---${NC}"
        echo "  Temporal needs its own PostgreSQL database."
        echo -n "  Temporal DB Host (e.g. db.example.com): "
        read -r temp_host
        if [ -z "$temp_host" ]; then
            log_error "Temporal DB Host cannot be empty."
            exit 1
        fi

        echo -n "  Temporal DB Port (default: 5432): "
        read -r temp_port
        temp_port=${temp_port:-5432}

        echo -n "  Temporal DB User (default: temporal): "
        read -r temp_user
        temp_user=${temp_user:-temporal}

        echo -n "  Temporal DB Password (default: temporal): "
        read -r temp_pass
        temp_pass=${temp_pass:-temporal}

        # Write to .env
        set_env_var "DATABASE_URL" "$pg_url"
        set_env_var "REDIS_URL" "$redis_url"
        set_env_var "TEMPORAL_POSTGRES_HOST" "$temp_host"
        set_env_var "TEMPORAL_DB_PORT" "$temp_port"
        set_env_var "TEMPORAL_POSTGRES_USER" "$temp_user"
        set_env_var "TEMPORAL_POSTGRES_PASSWORD" "$temp_pass"

        # Create docker-compose.override.yml to disable internal DB containers
        cat > docker-compose.override.yml <<'OVERRIDE_EOF'
# Auto-generated by ./postiz install (External DB mode)
# This file disables internal database containers.
# To switch back to internal, delete this file and run ./postiz install again.

services:
  postiz:
    depends_on: {}

  postiz-postgres:
    profiles: ["donotstart"]

  postiz-redis:
    profiles: ["donotstart"]

  temporal-postgresql:
    profiles: ["donotstart"]

  temporal:
    depends_on:
      temporal-elasticsearch:
        condition: service_started
OVERRIDE_EOF

        log_info "External database configuration saved."
        log_info "Created docker-compose.override.yml to disable internal DB containers."

    else
        # --- Internal Database Setup ---
        log_info "Using internal Docker-based databases."

        # Ensure default internal URLs are set
        set_env_var "DATABASE_URL" "postgresql://postiz-user:postiz-password@postiz-postgres:5432/postiz-db-local"
        set_env_var "REDIS_URL" "redis://postiz-redis:6379"

        # Remove any external-mode Temporal vars
        sedi '/^TEMPORAL_POSTGRES_HOST=/d' .env
        sedi '/^TEMPORAL_DB_PORT=/d' .env
        sedi '/^TEMPORAL_POSTGRES_USER=/d' .env
        sedi '/^TEMPORAL_POSTGRES_PASSWORD=/d' .env

        # Remove override if it was from external mode
        if [ -f docker-compose.override.yml ] && grep -q "donotstart" docker-compose.override.yml; then
            rm -f docker-compose.override.yml
            log_info "Removed external-mode docker-compose.override.yml"
        fi
    fi

    # --- Checkpoint 6: Start Services ---
    log_step "Checkpoint 6: Starting Postiz services..."

    docker compose --env-file .env up -d --remove-orphans

    echo ""
    echo -e "${GREEN}╔══════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║        Postiz Installation Complete!      ║${NC}"
    echo -e "${GREEN}╚══════════════════════════════════════════╝${NC}"
    echo ""
    FINAL_URL=$(get_env_var "FRONTEND_URL")
    FINAL_DOMAIN=$(get_env_var "DOMAIN")
    echo -e "  Access Postiz at: ${BOLD}${FINAL_URL:-http://localhost}${NC}"
    if [ "$FINAL_DOMAIN" != "localhost" ] && [ -n "$FINAL_DOMAIN" ]; then
        echo -e "  SSL:              ${BOLD}Auto (Caddy + Let's Encrypt)${NC}"
        echo -e "  Domain:           ${BOLD}${FINAL_DOMAIN}${NC}"
    fi
    echo -e "  Temporal UI at:   ${BOLD}http://localhost:8080${NC}"
    echo ""
    echo -e "  Manage with:  ${CYAN}./postiz help${NC}"
    echo ""
}

# =============================================================================
# UPDATE
# =============================================================================
cmd_update() {
    echo ""
    log_info "Checking for updates..."

    log_step "Pulling latest code..."
    # Stash any local changes to docker-compose files to prevent conflicts
    git stash push -m "postiz-update-autostash" -- docker-compose.override.yml 2>/dev/null || true
    git pull --ff-only || {
        log_warn "Fast-forward pull failed. Trying rebase..."
        git pull --rebase || {
            log_error "Git pull failed. You may have local modifications."
            log_error "Try: git stash && ./postiz update && git stash pop"
            exit 1
        }
    }
    # Restore stashed override
    git stash pop 2>/dev/null || true

    log_step "Pulling latest Docker images..."
    docker compose --env-file .env pull

    log_step "Restarting services with new images..."
    docker compose --env-file .env up -d --remove-orphans

    echo ""
    log_info "Update complete! All data preserved."
    echo ""
}

# =============================================================================
# JWT MANAGEMENT
# =============================================================================
cmd_jwt() {
    if [ ! -f .env ]; then
        log_error ".env file not found. Run ./postiz install first."
        exit 1
    fi

    local secret
    secret=$(get_env_var "JWT_SECRET")

    echo ""
    echo -e "  ${BOLD}Current JWT Secret:${NC}"
    echo "  $secret"
    echo ""
}

cmd_reset_jwt() {
    if [ ! -f .env ]; then
        log_error ".env file not found. Run ./postiz install first."
        exit 1
    fi

    echo ""
    log_warn "Resetting JWT Secret will invalidate ALL existing user sessions."
    echo -n "  Are you sure you want to continue? [y/N]: "
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        local new_secret
        new_secret=$(generate_jwt_secret)
        set_env_var "JWT_SECRET" "$new_secret"
        log_info "New JWT Secret generated and saved to .env"

        if docker compose ps -q postiz 2>/dev/null | grep -q .; then
            log_step "Restarting Postiz container to apply new secret..."
            docker compose --env-file .env restart postiz
            log_info "Postiz restarted with new JWT."
        else
            log_warn "Postiz container is not running. New secret will apply on next start."
        fi
        echo ""
    else
        echo "  Cancelled."
    fi
}

# =============================================================================
# HELP
# =============================================================================
cmd_help() {
    echo ""
    echo -e "${BOLD}Postiz Management CLI${NC}"
    echo ""
    echo "Usage: ./postiz <command>"
    echo ""
    echo "Commands:"
    echo "  install     Install and configure Postiz (interactive)"
    echo "  update      Update to the latest version (preserves data)"
    echo "  jwt         Show current JWT Secret"
    echo "  reset-jwt   Rotate JWT Secret and restart Postiz"
    echo "  help        Show this help message"
    echo ""
    echo "One-liner install:"
    echo "  curl -fsSL https://raw.githubusercontent.com/Rita5fr/postiz-app/main/install.sh | bash"
    echo ""
}

# =============================================================================
# MAIN DISPATCHER
# =============================================================================
if [ -z "$1" ]; then
    cmd_help
    exit 0
fi

case "$1" in
    install)    cmd_install ;;
    update)     cmd_update ;;
    jwt)        cmd_jwt ;;
    reset-jwt)  cmd_reset_jwt ;;
    help|--help|-h) cmd_help ;;
    *)
        log_error "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
